{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Are you developing or maintaining a server-side rendered website and want to add some ajax functionality to improve UX? Ajax tools will help you to achieve it with ease.</p>"},{"location":"#tldr","title":"TL;DR;","text":"<p>Following example shows an oversimplified product page with mini cart icon, 'add to cart' form and links to different product color variations. Click on 'add to cart' button should update the mini cart icon with the new amount and click on color variation links updates the product data and the form. While the example if oversimplified it contains all client-side js you'll need to implement these features.</p> main.js<pre><code>import ajt from './ajt/index.js'\ndocument.querySelectorAll('[data-ajt-trigger]').forEach(el =&gt; {/* (1)! */\nel.addEventListener(el.dataset.ajtTrigger, (event) =&gt; {\nevent.preventDefault();\najt(event);\n}\n});\ndocument.getElementById('mini-cart').addEventListener('click', () =&gt; {/* (2)! */\n});\n</code></pre> <ol> <li>Global setup. All events defined in attribute <code>data-ajt-trigger</code> will be intercepted and processed via ajt</li> <li><code>click</code> event listener used for demonstraction purpose</li> </ol> /product<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;script type=\"module\" src\"/js/main.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;header&gt;\n&lt;div id=\"mini-cart\"&gt;\n&lt;img src=\"empty-cart-icon.svg\"/&gt;\n&lt;div&gt;0&lt;/div&gt;\n&lt;/div&gt;\n&lt;/header&gt;\n&lt;div id=\"product-data\"&gt;\n&lt;!-- product image and description --&gt;\n&lt;/div&gt;\n&lt;a href=\"/product?color=red\"\ndata-ajt-trigger=\"click\"&gt;Red&lt;a&gt;&lt;!-- (1)! --&gt;\n&lt;a href=\"/product?color=green\"\ndata-ajt-trigger=\"click\"&gt;Green&lt;a&gt;&lt;!-- (2)! --&gt;\n&lt;form id=\"cart-form\"\naction=\"/cart\"\nmethod=\"post\"\ndata-ajt-trigger=\"submit\"&gt;&lt;!-- (3)! --&gt;\n&lt;input type=\"hidden\" name=\"product-id\" value=\"prod_0001\" /&gt;\n&lt;input type=\"number\" name=\"quantity\" /&gt;\n&lt;button&gt;Add product to cart&lt;/button&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ol> <li>Click on this link will update the <code>product-data</code> and the <code>cart-form</code> with the data of red product</li> <li>Click on this link will update the <code>product-data</code> and the <code>cart-form</code> with the data of green product</li> <li>Submitting the form will update the <code>mini-cart</code></li> </ol> /product?color=red<pre><code>&lt;div id=\"product-data\" data-ajt-mode=\"replace\"&gt;&lt;!-- (1)! --&gt;\n&lt;!-- red product image and description --&gt;\n&lt;/div&gt;\n&lt;form id=\"cart-form\"\naction=\"/cart\"\nmethod=\"post\"\ndata-ajt-trigger=\"submit\"\ndata-ajt-mode=\"update\"&gt;&lt;!-- (2)! --&gt;\n&lt;input type=\"hidden\" name=\"product-id\" value=\"prod_0001_red\" /&gt;\n&lt;input type=\"number\" name=\"quantity\" /&gt;\n&lt;button&gt;Add product to cart&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <ol> <li>Mode <code>replace</code> will replace the element with the same <code>id</code> in the current document</li> <li>Mode <code>upadate</code> will merge the attributes and the content of element with the same <code>id</code> in the current document. Useful for forms to keep users input after updating the html.</li> </ol> /product?color=green<pre><code>&lt;div id=\"product-data\" data-ajt-mode=\"replace\"&gt;&lt;!-- (1)! --&gt;\n&lt;!-- green product image and description --&gt;\n&lt;/div&gt;\n&lt;form id=\"cart-form\"\naction=\"/cart\"\nmethod=\"post\"\ndata-ajt-trigger=\"submit\"\ndata-ajt-mode=\"update\"&gt;&lt;!-- (2)! --&gt;\n&lt;input type=\"hidden\" name=\"product-id\" value=\"prod_0001_green\" /&gt;\n&lt;input type=\"number\" name=\"quantity\" /&gt;\n&lt;button disabled&gt;Sold out&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <ol> <li>Mode <code>replace</code> will replace the element with the same <code>id</code> in the current document</li> <li>Mode <code>upadate</code> will merge the attributes and the content of element with the same <code>id</code> in the current document. Useful for forms to keep users input after updating the html.</li> </ol> /cart<pre><code>&lt;div id=\"mini-cart\" data-ajt-mode=\"replaceContent\"&gt;&lt;!-- (1)! --&gt;\n&lt;img src=\"full-cart-icon.svg\"/&gt;\n&lt;div&gt;&lt;!-- new quantity --&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <ol> <li>Mode <code>replace</code> will replace the content of the element with the same <code>id</code>. Useful to keep the listeners.</li> </ol>"},{"location":"#rationale","title":"Rationale","text":"<p>There are myriads of ways to add ajax to a SSR page in a modern web. Most of them share same downsides:</p>"},{"location":"#boilerplate-code","title":"Boilerplate code","text":"<p>Implementing ajax calls with jQuery or vanilla js is quite easy, but there is just so much boilerplate code. You make the XHR call/fetch, receive the response, parse json and update some html. Over and over and over again.</p>"},{"location":"#ever-growing-client-side-js","title":"Ever-growing client-side js","text":"<p>How often did you see a piece of js and asked yourself whether it is still used somewhere? Keeping you client-side code neat and tidy can be extremely difficult and tedious task. You can spend hours of thorough clean up work, but in the end lighthouse still tells you 90% of your code it not used. Ouch!</p>"},{"location":"#tigtht-coupling-between-templates-and-js","title":"Tigtht coupling between templates and js","text":"<p>In order to update html with the new data ajax functions will mostly rely on css selectors. That means when html changes you have to double-check the client-side js as well, which can difficult if some smarty-pants collegue concatenated class name. Sometimes there is just no suitable selector so devs end up adding css classes just for js, or worse, using combinators like <code>.some-element &gt; div:first-child &gt; span</code></p>"},{"location":"#html-rendering-in-js","title":"HTML rendering in js","text":"<p>Sometimes there is a need to add some new html rather than just update existing element. It can be cumbersome to render html in your client-side js without additional libraries. But the real pain is if you have to render the same html on server- and client-side, e.g. server renders the initial list of items and client renders new items added by user. Not very DRY.</p>"},{"location":"#ajax-tools-to-the-rescue","title":"Ajax tools to the rescue!","text":"<p>Ajax tools tackles all of these problems by offloading most of the decisions to the server-side. The response is in controll of what and how will be updated. As a result, most of ajax calls can be implemented without you writing js at all.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>At this stage of development I don't really care how you are going to add the library to your project. All that matters is that somehow you can load the index module of ajt.</p> in html<pre><code>&lt;script type=\"module\"&gt;\nimport ajt from './ajt/index.js'\n&lt;/script&gt;\n</code></pre> in js<pre><code>  import ajt from './ajt/index.js'\n</code></pre> <p>Next, you need to decide how you want to trigger ajt. Default ajt function expects either a url or click or sumbit event. There is no 'right' way to do it in my opinion. </p> global function<pre><code>&lt;script type=\"module\"&gt;\nimport ajt from './ajt/index.js'\nwindow.ajt = ajt;\n&lt;/script&gt;\n...\n&lt;a href=\"/\" onclick=\"event.preventDefault(); ajt(event)\"&gt;Click me!&lt;/a&gt;\n</code></pre> in js<pre><code>  import ajt from './ajt/index.js'\ndocument.querySelectorAll('[data-ajt-link]').forEach(el =&gt; {\nel.addEventListener('click', (event) =&gt; {\nevent.preventDefault();\najt(event);\n})\n})\n</code></pre> <p>These are two very simplistic approaches. Both of them would work. I'd advise to do whatever you feel is right for you, just make sure you prevent default event behavior where necessary. If page speed is a big deal for you, you could even use dynamic import.</p> <p>dynamit import<pre><code>&lt;script type=\"module\"&gt;\nwindow.ajt = function (urlOrEvent) {\nlet loadAjt = import('./ajt/index.js')}')\nlet currentTarget = null\nif (urlOrEvent instanceof Event) {\nurlOrEvent.preventDefault();\ncurrentTarget = event.currentTarget;\n}\nreturn loadAjt.then(module =&gt; {\nmodule.default(urlOrEvent, currentTarget)\n}).catch(err =&gt; {\nconsole.error(err)\n});\n}\n&lt;/script&gt;\n...\n&lt;a href=\"/\" onclick=\"event.preventDefault(); ajt(event)\"&gt;Click me!&lt;/a&gt;\n</code></pre> This way ajt won't be loaded until it's actually needed.</p>"},{"location":"getting-started/#updating-dom","title":"Updating DOM","text":"<p>Now comes the fun part. The one where you don't have to write same ajax handlers over and over again and update dom node by node. Instead of responding with json, as is usually the case, your server should respond with plain html. I assume you are doing good old server-side rendering anyway, otherwise you wouldn't be here. The content of your the response will define what should be updated and how. simple response<pre><code>&lt;div id=\"minicart\" data-ajt-mode=\"replace\"&gt;\n&lt;div&gt;{{count}}&lt;/div&gt;\n&lt;img src=\"/cart-icon.svg\"/&gt;\n&lt;/div&gt;\n</code></pre> What to update is defined by id. There is another way to do it, but id is the default target for ajt. How to update is defined by data-ajt-mode attribute. <code>data-ajt-mode=\"replace\"</code> means that element with <code>id=\"minicart\"</code> in the current document will be replaced with the new element. The beauty of this approach is that it allows you to re-use templates. You can create dedicated template for the 'minicart' element and then include it in the page template and the response template</p>"}]}